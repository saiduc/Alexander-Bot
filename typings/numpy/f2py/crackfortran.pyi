"""
This type stub file was generated by pyright.
"""

import re
from . import __version__
from .auxfuncs import *

"""
crackfortran --- read fortran (77,90) code and extract declaration information.

Copyright 1999-2004 Pearu Peterson all rights reserved,
Pearu Peterson <pearu@ioc.ee>
Permission to use, modify, and distribute this software is given under the
terms of the NumPy License.

NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.
$Date: 2005/09/27 07:13:49 $
Pearu Peterson


Usage of crackfortran:
======================
Command line keys: -quiet,-verbose,-fix,-f77,-f90,-show,-h <pyffilename>
                   -m <module name for f77 routines>,--ignore-contains
Functions: crackfortran, crack2fortran
The following Fortran statements/constructions are supported
(or will be if needed):
   block data,byte,call,character,common,complex,contains,data,
   dimension,double complex,double precision,end,external,function,
   implicit,integer,intent,interface,intrinsic,
   logical,module,optional,parameter,private,public,
   program,real,(sequence?),subroutine,type,use,virtual,
   include,pythonmodule
Note: 'virtual' is mapped to 'dimension'.
Note: 'implicit integer (z) static (z)' is 'implicit static (z)' (this is minor bug).
Note: code after 'contains' will be ignored until its scope ends.
Note: 'common' statement is extended: dimensions are moved to variable definitions
Note: f2py directive: <commentchar>f2py<line> is read as <line>
Note: pythonmodule is introduced to represent Python module

Usage:
  `postlist=crackfortran(files)`
  `postlist` contains declaration information read from the list of files `files`.
  `crack2fortran(postlist)` returns a fortran code to be saved to pyf-file

  `postlist` has the following structure:
 *** it is a list of dictionaries containing `blocks':
     B = {'block','body','vars','parent_block'[,'name','prefix','args','result',
          'implicit','externals','interfaced','common','sortvars',
          'commonvars','note']}
     B['block'] = 'interface' | 'function' | 'subroutine' | 'module' |
                  'program' | 'block data' | 'type' | 'pythonmodule'
     B['body'] --- list containing `subblocks' with the same structure as `blocks'
     B['parent_block'] --- dictionary of a parent block:
                             C['body'][<index>]['parent_block'] is C
     B['vars'] --- dictionary of variable definitions
     B['sortvars'] --- dictionary of variable definitions sorted by dependence (independent first)
     B['name'] --- name of the block (not if B['block']=='interface')
     B['prefix'] --- prefix string (only if B['block']=='function')
     B['args'] --- list of argument names if B['block']== 'function' | 'subroutine'
     B['result'] --- name of the return value (only if B['block']=='function')
     B['implicit'] --- dictionary {'a':<variable definition>,'b':...} | None
     B['externals'] --- list of variables being external
     B['interfaced'] --- list of variables being external and defined
     B['common'] --- dictionary of common blocks (list of objects)
     B['commonvars'] --- list of variables used in common blocks (dimensions are moved to variable definitions)
     B['from'] --- string showing the 'parents' of the current block
     B['use'] --- dictionary of modules used in current block:
         {<modulename>:{['only':<0|1>],['map':{<local_name1>:<use_name1>,...}]}}
     B['note'] --- list of LaTeX comments on the block
     B['f2pyenhancements'] --- optional dictionary
          {'threadsafe':'','fortranname':<name>,
           'callstatement':<C-expr>|<multi-line block>,
           'callprotoargument':<C-expr-list>,
           'usercode':<multi-line block>|<list of multi-line blocks>,
           'pymethoddef:<multi-line block>'
           }
     B['entry'] --- dictionary {entryname:argslist,..}
     B['varnames'] --- list of variable names given in the order of reading the
                       Fortran code, useful for derived types.
     B['saved_interface'] --- a string of scanned routine signature, defines explicit interface
 *** Variable definition is a dictionary
     D = B['vars'][<variable name>] =
     {'typespec'[,'attrspec','kindselector','charselector','=','typename']}
     D['typespec'] = 'byte' | 'character' | 'complex' | 'double complex' |
                     'double precision' | 'integer' | 'logical' | 'real' | 'type'
     D['attrspec'] --- list of attributes (e.g. 'dimension(<arrayspec>)',
                       'external','intent(in|out|inout|hide|c|callback|cache|aligned4|aligned8|aligned16)',
                       'optional','required', etc)
     K = D['kindselector'] = {['*','kind']} (only if D['typespec'] =
                         'complex' | 'integer' | 'logical' | 'real' )
     C = D['charselector'] = {['*','len','kind']}
                             (only if D['typespec']=='character')
     D['='] --- initialization expression string
     D['typename'] --- name of the type if D['typespec']=='type'
     D['dimension'] --- list of dimension bounds
     D['intent'] --- list of intent specifications
     D['depend'] --- list of variable names on which current variable depends on
     D['check'] --- list of C-expressions; if C-expr returns zero, exception is raised
     D['note'] --- list of LaTeX comments on the variable
 *** Meaning of kind/char selectors (few examples):
     D['typespec>']*K['*']
     D['typespec'](kind=K['kind'])
     character*C['*']
     character(len=C['len'],kind=C['kind'])
     (see also fortran type declaration statement formats below)

Fortran 90 type declaration statement format (F77 is subset of F90)
====================================================================
(Main source: IBM XL Fortran 5.1 Language Reference Manual)
type declaration = <typespec> [[<attrspec>]::] <entitydecl>
<typespec> = byte                          |
             character[<charselector>]     |
             complex[<kindselector>]       |
             double complex                |
             double precision              |
             integer[<kindselector>]       |
             logical[<kindselector>]       |
             real[<kindselector>]          |
             type(<typename>)
<charselector> = * <charlen>               |
             ([len=]<len>[,[kind=]<kind>]) |
             (kind=<kind>[,len=<len>])
<kindselector> = * <intlen>                |
             ([kind=]<kind>)
<attrspec> = comma separated list of attributes.
             Only the following attributes are used in
             building up the interface:
                external
                (parameter --- affects '=' key)
                optional
                intent
             Other attributes are ignored.
<intentspec> = in | out | inout
<arrayspec> = comma separated list of dimension bounds.
<entitydecl> = <name> [[*<charlen>][(<arrayspec>)] | [(<arrayspec>)]*<charlen>]
                      [/<init_expr>/ | =<init_expr>] [,<entitydecl>]

In addition, the following attributes are used: check,depend,note

TODO:
    * Apply 'parameter' attribute (e.g. 'integer parameter :: i=2' 'real x(i)'
                                   -> 'real x(2)')
    The above may be solved by creating appropriate preprocessor program, for example.

"""
f2py_version = __version__.version
strictf77 = 1
sourcecodeform = 'fix'
quiet = 0
verbose = 1
tabchar = 4 * ' '
pyffilename = ''
f77modulename = ''
skipemptyends = 0
ignorecontains = 1
dolowercase = 1
debug = []
beginpattern = ''
currentfilename = ''
expectbegin = 1
f90modulevars = {  }
filepositiontext = ''
gotnextfile = 1
groupcache = None
groupcounter = 0
grouplist = { groupcounter: [] }
groupname = ''
include_paths = []
neededmodule = - 1
onlyfuncs = []
previous_context = None
skipblocksuntil = - 1
skipfuncs = []
skipfunctions = []
usermodules = []
def reset_global_f2py_vars():
    ...

def outmess(line, flag=...):
    ...

defaultimplicitrules = {  }
badnames = {  }
invbadnames = {  }
def rmbadname1(name):
    ...

def rmbadname(names):
    ...

def undo_rmbadname1(name):
    ...

def undo_rmbadname(names):
    ...

def getextension(name):
    ...

is_f_file = re.compile(r'.*[.](for|ftn|f77|f)\Z', re.I).match
_has_f_header = re.compile(r'-[*]-\s*fortran\s*-[*]-', re.I).search
_has_f90_header = re.compile(r'-[*]-\s*f90\s*-[*]-', re.I).search
_has_fix_header = re.compile(r'-[*]-\s*fix\s*-[*]-', re.I).search
_free_f90_start = re.compile(r'[^c*]\s*[^\s\d\t]', re.I).match
def is_free_format(file):
    """Check if file is in free format Fortran."""
    ...

def readfortrancode(ffile, dowithline=..., istop=...):
    """
    Read fortran codes from files and
     1) Get rid of comments, line continuations, and empty lines; lower cases.
     2) Call dowithline(line) on every line.
     3) Recursively call itself when statement \"include '<filename>'\" is met.
    """
    ...

beforethisafter = r'\s*(?P<before>%s(?=\s*(\b(%s)\b)))' + r'\s*(?P<this>(\b(%s)\b))' + r'\s*(?P<after>%s)\s*\Z'
fortrantypes = r'character|logical|integer|real|complex|double\s*(precision\s*(complex|)|complex)|type(?=\s*\([\w\s,=(*)]*\))|byte'
typespattern = (re.compile(beforethisafter % ('', fortrantypes, fortrantypes, '.*'), re.I), 'type')
typespattern4implicit = re.compile(beforethisafter % ('', fortrantypes + '|static|automatic|undefined', fortrantypes + '|static|automatic|undefined', '.*'), re.I)
functionpattern = (re.compile(beforethisafter % (r'([a-z]+[\w\s(=*+-/)]*?|)', 'function', 'function', '.*'), re.I), 'begin')
subroutinepattern = (re.compile(beforethisafter % (r'[a-z\s]*?', 'subroutine', 'subroutine', '.*'), re.I), 'begin')
groupbegins77 = r'program|block\s*data'
beginpattern77 = (re.compile(beforethisafter % ('', groupbegins77, groupbegins77, '.*'), re.I), 'begin')
groupbegins90 = groupbegins77 + r'|module(?!\s*procedure)|python\s*module|interface|type(?!\s*\()'
beginpattern90 = (re.compile(beforethisafter % ('', groupbegins90, groupbegins90, '.*'), re.I), 'begin')
groupends = r'end|endprogram|endblockdata|endmodule|endpythonmodule|' r'endinterface|endsubroutine|endfunction'
endpattern = (re.compile(beforethisafter % ('', groupends, groupends, r'[\w\s]*'), re.I), 'end')
endifs = r'(end\s*(if|do|where|select|while|forall))|(module\s*procedure)'
endifpattern = (re.compile(beforethisafter % (r'[\w]*?', endifs, endifs, r'[\w\s]*'), re.I), 'endif')
implicitpattern = (re.compile(beforethisafter % ('', 'implicit', 'implicit', '.*'), re.I), 'implicit')
dimensionpattern = (re.compile(beforethisafter % ('', 'dimension|virtual', 'dimension|virtual', '.*'), re.I), 'dimension')
externalpattern = (re.compile(beforethisafter % ('', 'external', 'external', '.*'), re.I), 'external')
optionalpattern = (re.compile(beforethisafter % ('', 'optional', 'optional', '.*'), re.I), 'optional')
requiredpattern = (re.compile(beforethisafter % ('', 'required', 'required', '.*'), re.I), 'required')
publicpattern = (re.compile(beforethisafter % ('', 'public', 'public', '.*'), re.I), 'public')
privatepattern = (re.compile(beforethisafter % ('', 'private', 'private', '.*'), re.I), 'private')
intrinsicpattern = (re.compile(beforethisafter % ('', 'intrinsic', 'intrinsic', '.*'), re.I), 'intrinsic')
intentpattern = (re.compile(beforethisafter % ('', 'intent|depend|note|check', 'intent|depend|note|check', r'\s*\(.*?\).*'), re.I), 'intent')
parameterpattern = (re.compile(beforethisafter % ('', 'parameter', 'parameter', r'\s*\(.*'), re.I), 'parameter')
datapattern = (re.compile(beforethisafter % ('', 'data', 'data', '.*'), re.I), 'data')
callpattern = (re.compile(beforethisafter % ('', 'call', 'call', '.*'), re.I), 'call')
entrypattern = (re.compile(beforethisafter % ('', 'entry', 'entry', '.*'), re.I), 'entry')
callfunpattern = (re.compile(beforethisafter % ('', 'callfun', 'callfun', '.*'), re.I), 'callfun')
commonpattern = (re.compile(beforethisafter % ('', 'common', 'common', '.*'), re.I), 'common')
usepattern = (re.compile(beforethisafter % ('', 'use', 'use', '.*'), re.I), 'use')
containspattern = (re.compile(beforethisafter % ('', 'contains', 'contains', ''), re.I), 'contains')
formatpattern = (re.compile(beforethisafter % ('', 'format', 'format', '.*'), re.I), 'format')
f2pyenhancementspattern = (re.compile(beforethisafter % ('', 'threadsafe|fortranname|callstatement|callprotoargument|usercode|pymethoddef', 'threadsafe|fortranname|callstatement|callprotoargument|usercode|pymethoddef', '.*'), re.I | re.S), 'f2pyenhancements')
multilinepattern = (re.compile(r"\s*(?P<before>''')(?P<this>.*?)(?P<after>''')\s*\Z", re.S), 'multiline')
def split_by_unquoted(line, characters):
    """
    Splits the line into (line[:i], line[i:]),
    where i is the index of first occurrence of one of the characters
    not within quotes, or len(line) if no such index exists
    """
    ...

crackline_re_1 = re.compile(r'\s*(?P<result>\b[a-z]+[\w]*\b)\s*[=].*', re.I)
def crackline(line, reset=...):
    """
    reset=-1  --- initialize
    reset=0   --- crack the line
    reset=1   --- final check if mismatch of blocks occurred

    Cracked data is saved in grouplist[0].
    """
    ...

def markouterparen(line):
    ...

def markoutercomma(line, comma=...):
    ...

def unmarkouterparen(line):
    ...

def appenddecl(decl, decl2, force=...):
    ...

selectpattern = re.compile(r'\s*(?P<this>(@\(@.*?@\)@|[*][\d*]+|[*]\s*@\(@.*?@\)@|))(?P<after>.*)\Z', re.I)
nameargspattern = re.compile(r'\s*(?P<name>\b[\w$]+\b)\s*(@\(@\s*(?P<args>[\w\s,]*)\s*@\)@|)\s*((result(\s*@\(@\s*(?P<result>\b[\w$]+\b)\s*@\)@|))|(bind\s*@\(@\s*(?P<bind>.*)\s*@\)@))*\s*\Z', re.I)
callnameargspattern = re.compile(r'\s*(?P<name>\b[\w$]+\b)\s*@\(@\s*(?P<args>.*)\s*@\)@\s*\Z', re.I)
real16pattern = re.compile(r'([-+]?(?:\d+(?:\.\d*)?|\d*\.\d+))[dD]((?:[-+]?\d+)?)')
real8pattern = re.compile(r'([-+]?((?:\d+(?:\.\d*)?|\d*\.\d+))[eE]((?:[-+]?\d+)?)|(\d+\.\d*))')
_intentcallbackpattern = re.compile(r'intent\s*\(.*?\bcallback\b', re.I)
def analyzeline(m, case, line):
    ...

def appendmultiline(group, context_name, ml):
    ...

def cracktypespec0(typespec, ll):
    ...

namepattern = re.compile(r'\s*(?P<name>\b[\w]+\b)\s*(?P<after>.*)\s*\Z', re.I)
kindselector = re.compile(r'\s*(\(\s*(kind\s*=)?\s*(?P<kind>.*)\s*\)|[*]\s*(?P<kind2>.*?))\s*\Z', re.I)
charselector = re.compile(r'\s*(\((?P<lenkind>.*)\)|[*]\s*(?P<charlen>.*))\s*\Z', re.I)
lenkindpattern = re.compile(r'\s*(kind\s*=\s*(?P<kind>.*?)\s*(@,@\s*len\s*=\s*(?P<len>.*)|)|(len\s*=\s*|)(?P<len2>.*?)\s*(@,@\s*(kind\s*=\s*|)(?P<kind2>.*)|))\s*\Z', re.I)
lenarraypattern = re.compile(r'\s*(@\(@\s*(?!/)\s*(?P<array>.*?)\s*@\)@\s*[*]\s*(?P<len>.*?)|([*]\s*(?P<len2>.*?)|)\s*(@\(@\s*(?!/)\s*(?P<array2>.*?)\s*@\)@|))\s*(=\s*(?P<init>.*?)|(@\(@|)/\s*(?P<init2>.*?)\s*/(@\)@|)|)\s*\Z', re.I)
def removespaces(expr):
    ...

def markinnerspaces(line):
    ...

def updatevars(typespec, selector, attrspec, entitydecl):
    ...

def cracktypespec(typespec, selector):
    ...

def setattrspec(decl, attr, force=...):
    ...

def setkindselector(decl, sel, force=...):
    ...

def setcharselector(decl, sel, force=...):
    ...

def getblockname(block, unknown=...):
    ...

def setmesstext(block):
    ...

def get_usedict(block):
    ...

def get_useparameters(block, param_map=...):
    ...

def postcrack2(block, tab=..., param_map=...):
    ...

def postcrack(block, args=..., tab=...):
    """
    TODO:
          function return values
          determine expression types if in argument list
    """
    ...

def sortvarnames(vars):
    ...

def analyzecommon(block):
    ...

def analyzebody(block, args, tab=...):
    ...

def buildimplicitrules(block):
    ...

def myeval(e, g=..., l=...):
    ...

getlincoef_re_1 = re.compile(r'\A\b\w+\b\Z', re.I)
def getlincoef(e, xset):
    ...

_varname_match = re.compile(r'\A[a-z]\w*\Z').match
def getarrlen(dl, args, star=...):
    ...

word_pattern = re.compile(r'\b[a-z][\w$]*\b', re.I)
def get_sorted_names(vars):
    """
    """
    ...

def get_parameters(vars, global_params=...):
    ...

_is_kind_number = re.compile(r'\d+_').match
def analyzevars(block):
    ...

analyzeargs_re_1 = re.compile(r'\A[a-z]+[\w$]*\Z', re.I)
def expr2name(a, block, args=...):
    ...

def analyzeargs(block):
    ...

determineexprtype_re_1 = re.compile(r'\A\(.+?[,].+?\)\Z', re.I)
determineexprtype_re_2 = re.compile(r'\A[+-]?\d+(_(?P<name>[\w]+)|)\Z', re.I)
determineexprtype_re_3 = re.compile(r'\A[+-]?[\d.]+[\d+\-de.]*(_(?P<name>[\w]+)|)\Z', re.I)
determineexprtype_re_4 = re.compile(r'\A\(.*\)\Z', re.I)
determineexprtype_re_5 = re.compile(r'\A(?P<name>\w+)\s*\(.*?\)\s*\Z', re.I)
def determineexprtype(expr, vars, rules=...):
    ...

def crack2fortrangen(block, tab=..., as_interface=...):
    ...

def common2fortran(common, tab=...):
    ...

def use2fortran(use, tab=...):
    ...

def true_intent_list(var):
    ...

def vars2fortran(block, vars, args, tab=..., as_interface=...):
    """
    TODO:
    public sub
    ...
    """
    ...

def crackfortran(files):
    ...

def crack2fortran(block):
    ...

if __name__ == "__main__":
    files = []
    funcs = []
    f = 1
    f2 = 0
    f3 = 0
    showblocklist = 0
    postlist = crackfortran(files)
