"""
This type stub file was generated by pyright.
"""

import os
import time
from . import __version__
from .auxfuncs import debugcapi, gentitle, hascallstatement, hasexternals, hasinitvalue, hasnote, hasresultnote, isarray, isarrayofstrings, iscomplex, iscomplexarray, iscomplexfunction, iscomplexfunction_warn, isdummyroutine, isexternal, isfunction, isfunction_wrap, isint1array, isintent_c, isintent_callback, isintent_copy, isintent_hide, isintent_inout, isintent_nothide, isintent_out, isintent_overwrite, islogical, islong_complex, islong_double, islong_doublefunction, islong_long, islong_longfunction, ismoduleroutine, isoptional, isrequired, isscalar, issigned_long_longarray, isstring, isstringarray, isstringfunction, issubroutine, issubroutine_wrap, isthreadsafe, isunsigned, isunsigned_char, isunsigned_chararray, isunsigned_long_long, isunsigned_long_longarray, isunsigned_short, isunsigned_shortarray, l_and, l_not, l_or

"""

Rules for building C/API module with f2py2e.

Here is a skeleton of a new wrapper function (13Dec2001):

wrapper_function(args)
  declarations
  get_python_arguments, say, `a' and `b'

  get_a_from_python
  if (successful) {

    get_b_from_python
    if (successful) {

      callfortran
      if (successful) {

        put_a_to_python
        if (successful) {

          put_b_to_python
          if (successful) {

            buildvalue = ...

          }

        }

      }

    }
    cleanup_b

  }
  cleanup_a

  return buildvalue

Copyright 1999,2000 Pearu Peterson all rights reserved,
Pearu Peterson <pearu@ioc.ee>
Permission to use, modify, and distribute this software is given under the
terms of the NumPy License.

NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.
$Date: 2005/08/30 08:58:42 $
Pearu Peterson

"""
__version__ = "$Revision: 1.129 $"[10: - 1]
f2py_version = __version__.version
options = {  }
sepdict = {  }
generationtime = int(os.environ.get('SOURCE_DATE_EPOCH', time.time()))
module_rules = { 'modulebody': """\
/* File: #modulename#module.c
 * This file is auto-generated with f2py (version:#f2py_version#).
 * f2py is a Fortran to Python Interface Generator (FPIG), Second Edition,
 * written by Pearu Peterson <pearu@cens.ioc.ee>.
 * Generation date: """ + time.asctime(time.gmtime(generationtime)) + """
 * Do not edit this file directly unless you know what you are doing!!!
 */

#ifdef __cplusplus
extern \"C\" {
#endif

""" + gentitle("See f2py2e/cfuncs.py: includes") + """
#includes#
#includes0#

""" + gentitle("See f2py2e/rules.py: mod_rules['modulebody']") + """
static PyObject *#modulename#_error;
static PyObject *#modulename#_module;

""" + gentitle("See f2py2e/cfuncs.py: typedefs") + """
#typedefs#

""" + gentitle("See f2py2e/cfuncs.py: typedefs_generated") + """
#typedefs_generated#

""" + gentitle("See f2py2e/cfuncs.py: cppmacros") + """
#cppmacros#

""" + gentitle("See f2py2e/cfuncs.py: cfuncs") + """
#cfuncs#

""" + gentitle("See f2py2e/cfuncs.py: userincludes") + """
#userincludes#

""" + gentitle("See f2py2e/capi_rules.py: usercode") + """
#usercode#

/* See f2py2e/rules.py */
#externroutines#

""" + gentitle("See f2py2e/capi_rules.py: usercode1") + """
#usercode1#

""" + gentitle("See f2py2e/cb_rules.py: buildcallback") + """
#callbacks#

""" + gentitle("See f2py2e/rules.py: buildapi") + """
#body#

""" + gentitle("See f2py2e/f90mod_rules.py: buildhooks") + """
#f90modhooks#

""" + gentitle("See f2py2e/rules.py: module_rules['modulebody']") + """

""" + gentitle("See f2py2e/common_rules.py: buildhooks") + """
#commonhooks#

""" + gentitle("See f2py2e/rules.py") + """

static FortranDataDef f2py_routine_defs[] = {
#routine_defs#
\t{NULL}
};

static PyMethodDef f2py_module_methods[] = {
#pymethoddef#
\t{NULL,NULL}
};

static struct PyModuleDef moduledef = {
\tPyModuleDef_HEAD_INIT,
\t"#modulename#",
\tNULL,
\t-1,
\tf2py_module_methods,
\tNULL,
\tNULL,
\tNULL,
\tNULL
};

PyMODINIT_FUNC PyInit_#modulename#(void) {
\tint i;
\tPyObject *m,*d, *s, *tmp;
\tm = #modulename#_module = PyModule_Create(&moduledef);
\tPy_SET_TYPE(&PyFortran_Type, &PyType_Type);
\timport_array();
\tif (PyErr_Occurred())
\t\t{PyErr_SetString(PyExc_ImportError, \"can't initialize module #modulename# (failed to import numpy)\"); return m;}
\td = PyModule_GetDict(m);
\ts = PyString_FromString(\"$R""" + """evision: $\");
\tPyDict_SetItemString(d, \"__version__\", s);
\tPy_DECREF(s);
\ts = PyUnicode_FromString(
\t\t\"This module '#modulename#' is auto-generated with f2py (version:#f2py_version#).\\nFunctions:\\n\"\n#docs#\".\");
\tPyDict_SetItemString(d, \"__doc__\", s);
\tPy_DECREF(s);
\t#modulename#_error = PyErr_NewException (\"#modulename#.error\", NULL, NULL);
\t/*
\t * Store the error object inside the dict, so that it could get deallocated.
\t * (in practice, this is a module, so it likely will not and cannot.)
\t */
\tPyDict_SetItemString(d, \"_#modulename#_error\", #modulename#_error);
\tPy_DECREF(#modulename#_error);
\tfor(i=0;f2py_routine_defs[i].name!=NULL;i++) {
\t\ttmp = PyFortranObject_NewAsAttr(&f2py_routine_defs[i]);
\t\tPyDict_SetItemString(d, f2py_routine_defs[i].name, tmp);
\t\tPy_DECREF(tmp);
\t}
#initf2pywraphooks#
#initf90modhooks#
#initcommonhooks#
#interface_usercode#

#ifdef F2PY_REPORT_ATEXIT
\tif (! PyErr_Occurred())
\t\ton_exit(f2py_report_on_exit,(void*)\"#modulename#\");
#endif
\treturn m;
}
#ifdef __cplusplus
}
#endif
""",'separatorsfor': { 'latexdoc': '\n\n','restdoc': '\n\n' },'latexdoc': ['\\section{Module \\texttt{#texmodulename#}}\n', '#modnote#\n', '#latexdoc#'],'restdoc': ['Module #modulename#\n' + '=' * 80, '\n#restdoc#'] }
defmod_rules = [{ 'body': '/*eof body*/','method': '/*eof method*/','externroutines': '/*eof externroutines*/','routine_defs': '/*eof routine_defs*/','initf90modhooks': '/*eof initf90modhooks*/','initf2pywraphooks': '/*eof initf2pywraphooks*/','initcommonhooks': '/*eof initcommonhooks*/','latexdoc': '','restdoc': '','modnote': { hasnote: '#note#',l_not(hasnote): '' } }]
routine_rules = { 'separatorsfor': sepdict,'body': """
#begintitle#
static char doc_#apiname#[] = \"\\\n#docreturn##name#(#docsignatureshort#)\\n\\nWrapper for ``#name#``.\\\n\\n#docstrsigns#\";
/* #declfortranroutine# */
static PyObject *#apiname#(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           #functype# (*f2py_func)(#callprotoargument#)) {
\tPyObject * volatile capi_buildvalue = NULL;
\tvolatile int f2py_success = 1;
#decl#
\tstatic char *capi_kwlist[] = {#kwlist##kwlistopt##kwlistxa#NULL};
#usercode#
#routdebugenter#
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
\tif (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\\
\t\t\"#argformat#|#keyformat##xaformat#:#pyname#\",\\
\t\tcapi_kwlist#args_capi##keys_capi##keys_xa#))\n\t\treturn NULL;
#frompyobj#
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
#callfortranroutine#
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
\t\tif (f2py_success) {
#pyobjfrom#
/*end of pyobjfrom*/
\t\tCFUNCSMESS(\"Building return value.\\n\");
\t\tcapi_buildvalue = Py_BuildValue(\"#returnformat#\"#return#);
/*closepyobjfrom*/
#closepyobjfrom#
\t\t} /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
#cleanupfrompyobj#
\tif (capi_buildvalue == NULL) {
#routdebugfailure#
\t} else {
#routdebugleave#
\t}
\tCFUNCSMESS(\"Freeing memory.\\n\");
#freemem#
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
\treturn capi_buildvalue;
}
#endtitle#
""",'routine_defs': '#routine_def#','initf2pywraphooks': '#initf2pywraphook#','externroutines': '#declfortranroutine#','doc': '#docreturn##name#(#docsignature#)','docshort': '#docreturn##name#(#docsignatureshort#)','docs': '"\t#docreturn##name#(#docsignature#)\\n"\n','need': ['arrayobject.h', 'CFUNCSMESS', 'MINMAX'],'cppmacros': { debugcapi: '#define DEBUGCFUNCS' },'latexdoc': ['\\subsection{Wrapper function \\texttt{#texname#}}\n', """
\\noindent{{}\\verb@#docreturn##name#@{}}\\texttt{(#latexdocsignatureshort#)}
#routnote#

#latexdocstrsigns#
"""],'restdoc': ['Wrapped function ``#name#``\n' + '-' * 80] }
rout_rules = [{ 'separatorsfor': { 'callfortranroutine': '\n','routdebugenter': '\n','decl': '\n','routdebugleave': '\n','routdebugfailure': '\n','setjmpbuf': ' || ','docstrreq': '\n','docstropt': '\n','docstrout': '\n','docstrcbs': '\n','docstrsigns': '\\n"\n"','latexdocstrsigns': '\n','latexdocstrreq': '\n','latexdocstropt': '\n','latexdocstrout': '\n','latexdocstrcbs': '\n' },'kwlist': '','kwlistopt': '','callfortran': '','callfortranappend': '','docsign': '','docsignopt': '','decl': '/*decl*/','freemem': '/*freemem*/','docsignshort': '','docsignoptshort': '','docstrsigns': '','latexdocstrsigns': '','docstrreq': '\\nParameters\\n----------','docstropt': '\\nOther Parameters\\n----------------','docstrout': '\\nReturns\\n-------','docstrcbs': '\\nNotes\\n-----\\nCall-back functions::\\n','latexdocstrreq': '\\noindent Required arguments:','latexdocstropt': '\\noindent Optional arguments:','latexdocstrout': '\\noindent Return objects:','latexdocstrcbs': '\\noindent Call-back functions:','args_capi': '','keys_capi': '','functype': '','frompyobj': '/*frompyobj*/','cleanupfrompyobj': ['/*end of cleanupfrompyobj*/'],'pyobjfrom': '/*pyobjfrom*/','closepyobjfrom': ['/*end of closepyobjfrom*/'],'topyarr': '/*topyarr*/','routdebugleave': '/*routdebugleave*/','routdebugenter': '/*routdebugenter*/','routdebugfailure': '/*routdebugfailure*/','callfortranroutine': '/*callfortranroutine*/','argformat': '','keyformat': '','need_cfuncs': '','docreturn': '','return': '','returnformat': '','rformat': '','kwlistxa': '','keys_xa': '','xaformat': '','docsignxa': '','docsignxashort': '','initf2pywraphook': '','routnote': { hasnote: '--- #note#',l_not(hasnote): '' } }, { 'apiname': 'f2py_rout_#modulename#_#name#','pyname': '#modulename#.#name#','decl': '','_check': l_not(ismoduleroutine) }, { 'apiname': 'f2py_rout_#modulename#_#f90modulename#_#name#','pyname': '#modulename#.#f90modulename#.#name#','decl': '','_check': ismoduleroutine }, { 'functype': 'void','declfortranroutine': { l_and(l_not(l_or(ismoduleroutine, isintent_c)), l_not(isdummyroutine)): 'extern void #F_FUNC#(#fortranname#,#FORTRANNAME#)(#callprotoargument#);',l_and(l_not(ismoduleroutine), isintent_c, l_not(isdummyroutine)): 'extern void #fortranname#(#callprotoargument#);',ismoduleroutine: '',isdummyroutine: '' },'routine_def': { l_not(l_or(ismoduleroutine, isintent_c, isdummyroutine)): '\t{\"#name#\",-1,{{-1}},0,(char *)#F_FUNC#(#fortranname#,#FORTRANNAME#),(f2py_init_func)#apiname#,doc_#apiname#},',l_and(l_not(ismoduleroutine), isintent_c, l_not(isdummyroutine)): '\t{\"#name#\",-1,{{-1}},0,(char *)#fortranname#,(f2py_init_func)#apiname#,doc_#apiname#},',l_and(l_not(ismoduleroutine), isdummyroutine): '\t{\"#name#\",-1,{{-1}},0,NULL,(f2py_init_func)#apiname#,doc_#apiname#},' },'need': { l_and(l_not(l_or(ismoduleroutine, isintent_c)), l_not(isdummyroutine)): 'F_FUNC' },'callfortranroutine': [{ debugcapi: ["""\tfprintf(stderr,\"debug-capi:Fortran subroutine `#fortranname#(#callfortran#)\'\\n\");"""] }, { hasexternals: """\
\t\tif (#setjmpbuf#) {
\t\t\tf2py_success = 0;
\t\t} else {""" }, { isthreadsafe: '\t\t\tPy_BEGIN_ALLOW_THREADS' }, { hascallstatement: '''\t\t\t\t#callstatement#;
\t\t\t\t/*(*f2py_func)(#callfortran#);*/''' }, { l_not(l_or(hascallstatement, isdummyroutine)): '\t\t\t\t(*f2py_func)(#callfortran#);' }, { isthreadsafe: '\t\t\tPy_END_ALLOW_THREADS' }, { hasexternals: """\t\t}""" }],'_check': l_and(issubroutine, l_not(issubroutine_wrap)) }, { 'functype': 'void','declfortranroutine': { l_not(l_or(ismoduleroutine, isdummyroutine)): 'extern void #F_WRAPPEDFUNC#(#name_lower#,#NAME#)(#callprotoargument#);',isdummyroutine: '' },'routine_def': { l_not(l_or(ismoduleroutine, isdummyroutine)): '\t{\"#name#\",-1,{{-1}},0,(char *)#F_WRAPPEDFUNC#(#name_lower#,#NAME#),(f2py_init_func)#apiname#,doc_#apiname#},',isdummyroutine: '\t{\"#name#\",-1,{{-1}},0,NULL,(f2py_init_func)#apiname#,doc_#apiname#},' },'initf2pywraphook': { l_not(l_or(ismoduleroutine, isdummyroutine)): '''
    {
      extern #ctype# #F_FUNC#(#name_lower#,#NAME#)(void);
      PyObject* o = PyDict_GetItemString(d,"#name#");
      tmp = F2PyCapsule_FromVoidPtr((void*)#F_FUNC#(#name_lower#,#NAME#),NULL);
      PyObject_SetAttrString(o,"_cpointer", tmp);
      Py_DECREF(tmp);
      s = PyUnicode_FromString("#name#");
      PyObject_SetAttrString(o,"__name__", s);
      Py_DECREF(s);
    }
    ''' },'need': { l_not(l_or(ismoduleroutine, isdummyroutine)): ['F_WRAPPEDFUNC', 'F_FUNC'] },'callfortranroutine': [{ debugcapi: ["""\tfprintf(stderr,\"debug-capi:Fortran subroutine `f2pywrap#name_lower#(#callfortran#)\'\\n\");"""] }, { hasexternals: """\
\tif (#setjmpbuf#) {
\t\tf2py_success = 0;
\t} else {""" }, { isthreadsafe: '\tPy_BEGIN_ALLOW_THREADS' }, { l_not(l_or(hascallstatement, isdummyroutine)): '\t(*f2py_func)(#callfortran#);' }, { hascallstatement: '\t#callstatement#;\n\t/*(*f2py_func)(#callfortran#);*/' }, { isthreadsafe: '\tPy_END_ALLOW_THREADS' }, { hasexternals: '\t}' }],'_check': isfunction_wrap }, { 'functype': 'void','declfortranroutine': { l_not(l_or(ismoduleroutine, isdummyroutine)): 'extern void #F_WRAPPEDFUNC#(#name_lower#,#NAME#)(#callprotoargument#);',isdummyroutine: '' },'routine_def': { l_not(l_or(ismoduleroutine, isdummyroutine)): '\t{\"#name#\",-1,{{-1}},0,(char *)#F_WRAPPEDFUNC#(#name_lower#,#NAME#),(f2py_init_func)#apiname#,doc_#apiname#},',isdummyroutine: '\t{\"#name#\",-1,{{-1}},0,NULL,(f2py_init_func)#apiname#,doc_#apiname#},' },'initf2pywraphook': { l_not(l_or(ismoduleroutine, isdummyroutine)): '''
    {
      extern void #F_FUNC#(#name_lower#,#NAME#)(void);
      PyObject* o = PyDict_GetItemString(d,"#name#");
      tmp = F2PyCapsule_FromVoidPtr((void*)#F_FUNC#(#name_lower#,#NAME#),NULL);
      PyObject_SetAttrString(o,"_cpointer", tmp);
      Py_DECREF(tmp);
      s = PyUnicode_FromString("#name#");
      PyObject_SetAttrString(o,"__name__", s);
      Py_DECREF(s);
    }
    ''' },'need': { l_not(l_or(ismoduleroutine, isdummyroutine)): ['F_WRAPPEDFUNC', 'F_FUNC'] },'callfortranroutine': [{ debugcapi: ["""\tfprintf(stderr,\"debug-capi:Fortran subroutine `f2pywrap#name_lower#(#callfortran#)\'\\n\");"""] }, { hasexternals: """\
\tif (#setjmpbuf#) {
\t\tf2py_success = 0;
\t} else {""" }, { isthreadsafe: '\tPy_BEGIN_ALLOW_THREADS' }, { l_not(l_or(hascallstatement, isdummyroutine)): '\t(*f2py_func)(#callfortran#);' }, { hascallstatement: '\t#callstatement#;\n\t/*(*f2py_func)(#callfortran#);*/' }, { isthreadsafe: '\tPy_END_ALLOW_THREADS' }, { hasexternals: '\t}' }],'_check': issubroutine_wrap }, { 'functype': '#ctype#','docreturn': { l_not(isintent_hide): '#rname#,' },'docstrout': '#pydocsignout#','latexdocstrout': ['\\item[]{{}\\verb@#pydocsignout#@{}}', { hasresultnote: '--- #resultnote#' }],'callfortranroutine': [{ l_and(debugcapi, isstringfunction): """\
#ifdef USESCOMPAQFORTRAN
\tfprintf(stderr,\"debug-capi:Fortran function #ctype# #fortranname#(#callcompaqfortran#)\\n\");
#else
\tfprintf(stderr,\"debug-capi:Fortran function #ctype# #fortranname#(#callfortran#)\\n\");
#endif
""" }, { l_and(debugcapi, l_not(isstringfunction)): """\
\tfprintf(stderr,\"debug-capi:Fortran function #ctype# #fortranname#(#callfortran#)\\n\");
""" }],'_check': l_and(isfunction, l_not(isfunction_wrap)) }, { 'declfortranroutine': { l_and(l_not(l_or(ismoduleroutine, isintent_c)), l_not(isdummyroutine)): 'extern #ctype# #F_FUNC#(#fortranname#,#FORTRANNAME#)(#callprotoargument#);',l_and(l_not(ismoduleroutine), isintent_c, l_not(isdummyroutine)): 'extern #ctype# #fortranname#(#callprotoargument#);',isdummyroutine: '' },'routine_def': { l_and(l_not(l_or(ismoduleroutine, isintent_c)), l_not(isdummyroutine)): '\t{\"#name#\",-1,{{-1}},0,(char *)#F_FUNC#(#fortranname#,#FORTRANNAME#),(f2py_init_func)#apiname#,doc_#apiname#},',l_and(l_not(ismoduleroutine), isintent_c, l_not(isdummyroutine)): '\t{\"#name#\",-1,{{-1}},0,(char *)#fortranname#,(f2py_init_func)#apiname#,doc_#apiname#},',isdummyroutine: '\t{\"#name#\",-1,{{-1}},0,NULL,(f2py_init_func)#apiname#,doc_#apiname#},' },'decl': [{ iscomplexfunction_warn: '\t#ctype# #name#_return_value={0,0};',l_not(iscomplexfunction): '\t#ctype# #name#_return_value=0;' }, { iscomplexfunction: '\tPyObject *#name#_return_value_capi = Py_None;' }],'callfortranroutine': [{ hasexternals: """\
\tif (#setjmpbuf#) {
\t\tf2py_success = 0;
\t} else {""" }, { isthreadsafe: '\tPy_BEGIN_ALLOW_THREADS' }, { hascallstatement: '''\t#callstatement#;
/*\t#name#_return_value = (*f2py_func)(#callfortran#);*/
''' }, { l_not(l_or(hascallstatement, isdummyroutine)): '\t#name#_return_value = (*f2py_func)(#callfortran#);' }, { isthreadsafe: '\tPy_END_ALLOW_THREADS' }, { hasexternals: '\t}' }, { l_and(debugcapi, iscomplexfunction): '\tfprintf(stderr,"#routdebugshowvalue#\\n",#name#_return_value.r,#name#_return_value.i);' }, { l_and(debugcapi, l_not(iscomplexfunction)): '\tfprintf(stderr,"#routdebugshowvalue#\\n",#name#_return_value);' }],'pyobjfrom': { iscomplexfunction: '\t#name#_return_value_capi = pyobj_from_#ctype#1(#name#_return_value);' },'need': [{ l_not(isdummyroutine): 'F_FUNC' }, { iscomplexfunction: 'pyobj_from_#ctype#1' }, { islong_longfunction: 'long_long' }, { islong_doublefunction: 'long_double' }],'returnformat': { l_not(isintent_hide): '#rformat#' },'return': { iscomplexfunction: ',#name#_return_value_capi',l_not(l_or(iscomplexfunction, isintent_hide)): ',#name#_return_value' },'_check': l_and(isfunction, l_not(isstringfunction), l_not(isfunction_wrap)) }, { 'declfortranroutine': 'extern void #F_FUNC#(#fortranname#,#FORTRANNAME#)(#callprotoargument#);','routine_def': { l_not(l_or(ismoduleroutine, isintent_c)): '\t{\"#name#\",-1,{{-1}},0,(char *)#F_FUNC#(#fortranname#,#FORTRANNAME#),(f2py_init_func)#apiname#,doc_#apiname#},',l_and(l_not(ismoduleroutine), isintent_c): '\t{\"#name#\",-1,{{-1}},0,(char *)#fortranname#,(f2py_init_func)#apiname#,doc_#apiname#},' },'decl': ['\t#ctype# #name#_return_value = NULL;', '\tint #name#_return_value_len = 0;'],'callfortran': '#name#_return_value,#name#_return_value_len,','callfortranroutine': ['\t#name#_return_value_len = #rlength#;', '\tif ((#name#_return_value = (string)malloc(sizeof(char)*(#name#_return_value_len+1))) == NULL) {', '\t\tPyErr_SetString(PyExc_MemoryError, \"out of memory\");', '\t\tf2py_success = 0;', '\t} else {', "\t\t(#name#_return_value)[#name#_return_value_len] = '\\0';", '\t}', '\tif (f2py_success) {', { hasexternals: """\
\t\tif (#setjmpbuf#) {
\t\t\tf2py_success = 0;
\t\t} else {""" }, { isthreadsafe: '\t\tPy_BEGIN_ALLOW_THREADS' }, """\
#ifdef USESCOMPAQFORTRAN
\t\t(*f2py_func)(#callcompaqfortran#);
#else
\t\t(*f2py_func)(#callfortran#);
#endif
""", { isthreadsafe: '\t\tPy_END_ALLOW_THREADS' }, { hasexternals: '\t\t}' }, { debugcapi: '\t\tfprintf(stderr,"#routdebugshowvalue#\\n",#name#_return_value_len,#name#_return_value);' }, '\t} /* if (f2py_success) after (string)malloc */'],'returnformat': '#rformat#','return': ',#name#_return_value','freemem': '\tSTRINGFREE(#name#_return_value);','need': ['F_FUNC', '#ctype#', 'STRINGFREE'],'_check': l_and(isstringfunction, l_not(isfunction_wrap)) }, { 'routdebugenter': '\tfprintf(stderr,"debug-capi:Python C/API function #modulename#.#name#(#docsignature#)\\n");','routdebugleave': '\tfprintf(stderr,"debug-capi:Python C/API function #modulename#.#name#: successful.\\n");','routdebugfailure': '\tfprintf(stderr,"debug-capi:Python C/API function #modulename#.#name#: failure.\\n");','_check': debugcapi }]
typedef_need_dict = { islong_long: 'long_long',islong_double: 'long_double',islong_complex: 'complex_long_double',isunsigned_char: 'unsigned_char',isunsigned_short: 'unsigned_short',isunsigned: 'unsigned',isunsigned_long_long: 'unsigned_long_long',isunsigned_chararray: 'unsigned_char',isunsigned_shortarray: 'unsigned_short',isunsigned_long_longarray: 'unsigned_long_long',issigned_long_longarray: 'long_long' }
aux_rules = [{ 'separatorsfor': sepdict }, { 'frompyobj': ['\t/* Processing auxiliary variable #varname# */', { debugcapi: '\tfprintf(stderr,"#vardebuginfo#\\n");' }],'cleanupfrompyobj': '\t/* End of cleaning variable #varname# */','need': typedef_need_dict }, { 'decl': '\t#ctype# #varname# = 0;','need': { hasinitvalue: 'math.h' },'frompyobj': { hasinitvalue: '\t#varname# = #init#;' },'_check': l_and(isscalar, l_not(iscomplex)) }, { 'return': ',#varname#','docstrout': '#pydocsignout#','docreturn': '#outvarname#,','returnformat': '#varrformat#','_check': l_and(isscalar, l_not(iscomplex), isintent_out) }, { 'decl': '\t#ctype# #varname#;','frompyobj': { hasinitvalue: '\t#varname#.r = #init.r#, #varname#.i = #init.i#;' },'_check': iscomplex }, { 'decl': ['\t#ctype# #varname# = NULL;', '\tint slen(#varname#);'],'need': ['len..'],'_check': isstring }, { 'decl': ['\t#ctype# *#varname# = NULL;', '\tnpy_intp #varname#_Dims[#rank#] = {#rank*[-1]#};', '\tconst int #varname#_Rank = #rank#;'],'need': ['len..', { hasinitvalue: 'forcomb' }, { hasinitvalue: 'CFUNCSMESS' }],'_check': isarray }, { '_check': l_and(isarray, l_not(iscomplexarray)) }, { '_check': l_and(isarray, l_not(iscomplexarray), isintent_nothide) }, { 'need': '#ctype#','_check': isint1array,'_depend': '' }, { 'need': '#ctype#','_check': isunsigned_chararray,'_depend': '' }, { 'need': '#ctype#','_check': isunsigned_shortarray,'_depend': '' }, { 'need': '#ctype#','_check': isunsigned_long_longarray,'_depend': '' }, { 'need': '#ctype#','_check': iscomplexarray,'_depend': '' }, { 'callfortranappend': { isarrayofstrings: 'flen(#varname#),' },'need': 'string','_check': isstringarray }]
arg_rules = [{ 'separatorsfor': sepdict }, { 'frompyobj': ['\t/* Processing variable #varname# */', { debugcapi: '\tfprintf(stderr,"#vardebuginfo#\\n");' }],'cleanupfrompyobj': '\t/* End of cleaning variable #varname# */','_depend': '','need': typedef_need_dict }, { 'docstropt': { l_and(isoptional, isintent_nothide): '#pydocsign#' },'docstrreq': { l_and(isrequired, isintent_nothide): '#pydocsign#' },'docstrout': { isintent_out: '#pydocsignout#' },'latexdocstropt': { l_and(isoptional, isintent_nothide): ['\\item[]{{}\\verb@#pydocsign#@{}}', { hasnote: '--- #note#' }] },'latexdocstrreq': { l_and(isrequired, isintent_nothide): ['\\item[]{{}\\verb@#pydocsign#@{}}', { hasnote: '--- #note#' }] },'latexdocstrout': { isintent_out: ['\\item[]{{}\\verb@#pydocsignout#@{}}', { l_and(hasnote, isintent_hide): '--- #note#',l_and(hasnote, isintent_nothide): '--- See above.' }] },'depend': '' }, { 'kwlist': '"#varname#",','docsign': '#varname#,','_check': l_and(isintent_nothide, l_not(isoptional)) }, { 'kwlistopt': '"#varname#",','docsignopt': '#varname#=#showinit#,','docsignoptshort': '#varname#,','_check': l_and(isintent_nothide, isoptional) }, { 'docreturn': '#outvarname#,','returnformat': '#varrformat#','_check': isintent_out }, { 'docsignxa': { isintent_nothide: '#varname#_extra_args=(),' },'docsignxashort': { isintent_nothide: '#varname#_extra_args,' },'docstropt': { isintent_nothide: '#varname#_extra_args : input tuple, optional\\n    Default: ()' },'docstrcbs': '#cbdocstr#','latexdocstrcbs': '\\item[] #cblatexdocstr#','latexdocstropt': { isintent_nothide: '\\item[]{{}\\verb@#varname#_extra_args := () input tuple@{}} --- Extra arguments for call-back function {{}\\verb@#varname#@{}}.' },'decl': ['\tPyObject *#varname#_capi = Py_None;', '\tPyTupleObject *#varname#_xa_capi = NULL;', '\tPyTupleObject *#varname#_args_capi = NULL;', '\tint #varname#_nofargs_capi = 0;', { l_not(isintent_callback): '\t#cbname#_typedef #varname#_cptr;' }],'kwlistxa': { isintent_nothide: '"#varname#_extra_args",' },'argformat': { isrequired: 'O' },'keyformat': { isoptional: 'O' },'xaformat': { isintent_nothide: 'O!' },'args_capi': { isrequired: ',&#varname#_capi' },'keys_capi': { isoptional: ',&#varname#_capi' },'keys_xa': ',&PyTuple_Type,&#varname#_xa_capi','setjmpbuf': '(setjmp(#cbname#_jmpbuf))','callfortran': { l_not(isintent_callback): '#varname#_cptr,' },'need': ['#cbname#', 'setjmp.h'],'_check': isexternal }, { 'frompyobj': [{ l_not(isintent_callback): """\
if(F2PyCapsule_Check(#varname#_capi)) {
  #varname#_cptr = F2PyCapsule_AsVoidPtr(#varname#_capi);
} else {
  #varname#_cptr = #cbname#;
}
""" }, { isintent_callback: """\
if (#varname#_capi==Py_None) {
  #varname#_capi = PyObject_GetAttrString(#modulename#_module,\"#varname#\");
  if (#varname#_capi) {
    if (#varname#_xa_capi==NULL) {
      if (PyObject_HasAttrString(#modulename#_module,\"#varname#_extra_args\")) {
        PyObject* capi_tmp = PyObject_GetAttrString(#modulename#_module,\"#varname#_extra_args\");
        if (capi_tmp) {
          #varname#_xa_capi = (PyTupleObject *)PySequence_Tuple(capi_tmp);
          Py_DECREF(capi_tmp);
        }
        else {
          #varname#_xa_capi = (PyTupleObject *)Py_BuildValue(\"()\");
        }
        if (#varname#_xa_capi==NULL) {
          PyErr_SetString(#modulename#_error,\"Failed to convert #modulename#.#varname#_extra_args to tuple.\\n\");
          return NULL;
        }
      }
    }
  }
  if (#varname#_capi==NULL) {
    PyErr_SetString(#modulename#_error,\"Callback #varname# not defined (as an argument or module #modulename# attribute).\\n\");
    return NULL;
  }
}
""" }, """\
\t#varname#_nofargs_capi = #cbname#_nofargs;
\tif (create_cb_arglist(#varname#_capi,#varname#_xa_capi,#maxnofargs#,#nofoptargs#,&#cbname#_nofargs,&#varname#_args_capi,\"failed in processing argument list for call-back #varname#.\")) {
\t\tjmp_buf #varname#_jmpbuf;""", { debugcapi: ["""\
\t\tfprintf(stderr,\"debug-capi:Assuming %d arguments; at most #maxnofargs#(-#nofoptargs#) is expected.\\n\",#cbname#_nofargs);
\t\tCFUNCSMESSPY(\"for #varname#=\",#cbname#_capi);""", { l_not(isintent_callback): """\t\tfprintf(stderr,\"#vardebugshowvalue# (call-back in C).\\n\",#cbname#);""" }] }, """\
\t\tCFUNCSMESS(\"Saving jmpbuf for `#varname#`.\\n\");
\t\tSWAP(#varname#_capi,#cbname#_capi,PyObject);
\t\tSWAP(#varname#_args_capi,#cbname#_args_capi,PyTupleObject);
\t\tmemcpy(&#varname#_jmpbuf,&#cbname#_jmpbuf,sizeof(jmp_buf));"""],'cleanupfrompyobj': """\
\t\tCFUNCSMESS(\"Restoring jmpbuf for `#varname#`.\\n\");
\t\t#cbname#_capi = #varname#_capi;
\t\tPy_DECREF(#cbname#_args_capi);
\t\t#cbname#_args_capi = #varname#_args_capi;
\t\t#cbname#_nofargs = #varname#_nofargs_capi;
\t\tmemcpy(&#cbname#_jmpbuf,&#varname#_jmpbuf,sizeof(jmp_buf));
\t}""",'need': ['SWAP', 'create_cb_arglist'],'_check': isexternal,'_depend': '' }, { 'decl': '\t#ctype# #varname# = 0;','pyobjfrom': { debugcapi: '\tfprintf(stderr,"#vardebugshowvalue#\\n",#varname#);' },'callfortran': { isintent_c: '#varname#,',l_not(isintent_c): '&#varname#,' },'return': { isintent_out: ',#varname#' },'_check': l_and(isscalar, l_not(iscomplex)) }, { 'need': { hasinitvalue: 'math.h' },'_check': l_and(isscalar, l_not(iscomplex)) }, { 'decl': '\tPyObject *#varname#_capi = Py_None;','argformat': { isrequired: 'O' },'keyformat': { isoptional: 'O' },'args_capi': { isrequired: ',&#varname#_capi' },'keys_capi': { isoptional: ',&#varname#_capi' },'pyobjfrom': { isintent_inout: """\
\tf2py_success = try_pyarr_from_#ctype#(#varname#_capi,&#varname#);
\tif (f2py_success) {""" },'closepyobjfrom': { isintent_inout: "\t} /*if (f2py_success) of #varname# pyobjfrom*/" },'need': { isintent_inout: 'try_pyarr_from_#ctype#' },'_check': l_and(isscalar, l_not(iscomplex), isintent_nothide) }, { 'frompyobj': [{ hasinitvalue: '\tif (#varname#_capi == Py_None) #varname# = #init#; else','_depend': '' }, { l_and(isoptional, l_not(hasinitvalue)): '\tif (#varname#_capi != Py_None)','_depend': '' }, { l_not(islogical): '''\
\t\tf2py_success = #ctype#_from_pyobj(&#varname#,#varname#_capi,"#pyname#() #nth# (#varname#) can\'t be converted to #ctype#");
\tif (f2py_success) {''' }, { islogical: '''\
\t\t#varname# = (#ctype#)PyObject_IsTrue(#varname#_capi);
\t\tf2py_success = 1;
\tif (f2py_success) {''' }],'cleanupfrompyobj': '\t} /*if (f2py_success) of #varname#*/','need': { l_not(islogical): '#ctype#_from_pyobj' },'_check': l_and(isscalar, l_not(iscomplex), isintent_nothide),'_depend': '' }, { 'frompyobj': { hasinitvalue: '\t#varname# = #init#;' },'need': typedef_need_dict,'_check': l_and(isscalar, l_not(iscomplex), isintent_hide),'_depend': '' }, { 'frompyobj': { debugcapi: '\tfprintf(stderr,"#vardebugshowvalue#\\n",#varname#);' },'_check': l_and(isscalar, l_not(iscomplex)),'_depend': '' }, { 'decl': '\t#ctype# #varname#;','callfortran': { isintent_c: '#varname#,',l_not(isintent_c): '&#varname#,' },'pyobjfrom': { debugcapi: '\tfprintf(stderr,"#vardebugshowvalue#\\n",#varname#.r,#varname#.i);' },'return': { isintent_out: ',#varname#_capi' },'_check': iscomplex }, { 'decl': '\tPyObject *#varname#_capi = Py_None;','argformat': { isrequired: 'O' },'keyformat': { isoptional: 'O' },'args_capi': { isrequired: ',&#varname#_capi' },'keys_capi': { isoptional: ',&#varname#_capi' },'need': { isintent_inout: 'try_pyarr_from_#ctype#' },'pyobjfrom': { isintent_inout: """\
\t\tf2py_success = try_pyarr_from_#ctype#(#varname#_capi,&#varname#);
\t\tif (f2py_success) {""" },'closepyobjfrom': { isintent_inout: "\t\t} /*if (f2py_success) of #varname# pyobjfrom*/" },'_check': l_and(iscomplex, isintent_nothide) }, { 'frompyobj': [{ hasinitvalue: '\tif (#varname#_capi==Py_None) {#varname#.r = #init.r#, #varname#.i = #init.i#;} else' }, { l_and(isoptional, l_not(hasinitvalue)): '\tif (#varname#_capi != Py_None)' }, '\t\tf2py_success = #ctype#_from_pyobj(&#varname#,#varname#_capi,"#pyname#() #nth# (#varname#) can\'t be converted to #ctype#");' '\n\tif (f2py_success) {'],'cleanupfrompyobj': '\t}  /*if (f2py_success) of #varname# frompyobj*/','need': ['#ctype#_from_pyobj'],'_check': l_and(iscomplex, isintent_nothide),'_depend': '' }, { 'decl': { isintent_out: '\tPyObject *#varname#_capi = Py_None;' },'_check': l_and(iscomplex, isintent_hide) }, { 'frompyobj': { hasinitvalue: '\t#varname#.r = #init.r#, #varname#.i = #init.i#;' },'_check': l_and(iscomplex, isintent_hide),'_depend': '' }, { 'pyobjfrom': { isintent_out: '\t#varname#_capi = pyobj_from_#ctype#1(#varname#);' },'need': ['pyobj_from_#ctype#1'],'_check': iscomplex }, { 'frompyobj': { debugcapi: '\tfprintf(stderr,"#vardebugshowvalue#\\n",#varname#.r,#varname#.i);' },'_check': iscomplex,'_depend': '' }, { 'decl': ['\t#ctype# #varname# = NULL;', '\tint slen(#varname#);', '\tPyObject *#varname#_capi = Py_None;'],'callfortran': '#varname#,','callfortranappend': 'slen(#varname#),','pyobjfrom': { debugcapi: '\tfprintf(stderr,"#vardebugshowvalue#\\n",slen(#varname#),#varname#);' },'return': { isintent_out: ',#varname#' },'need': ['len..'],'_check': isstring }, { 'frompyobj': """\
\tslen(#varname#) = #length#;
\tf2py_success = #ctype#_from_pyobj(&#varname#,&slen(#varname#),#init#,#varname#_capi,\"#ctype#_from_pyobj failed in converting #nth# `#varname#\' of #pyname# to C #ctype#\");
\tif (f2py_success) {""",'cleanupfrompyobj': """\
\t\tSTRINGFREE(#varname#);
\t}  /*if (f2py_success) of #varname#*/""",'need': ['#ctype#_from_pyobj', 'len..', 'STRINGFREE'],'_check': isstring,'_depend': '' }, { 'argformat': { isrequired: 'O' },'keyformat': { isoptional: 'O' },'args_capi': { isrequired: ',&#varname#_capi' },'keys_capi': { isoptional: ',&#varname#_capi' },'pyobjfrom': { isintent_inout: '''\
\tf2py_success = try_pyarr_from_#ctype#(#varname#_capi,#varname#);
\tif (f2py_success) {''' },'closepyobjfrom': { isintent_inout: '\t} /*if (f2py_success) of #varname# pyobjfrom*/' },'need': { isintent_inout: 'try_pyarr_from_#ctype#' },'_check': l_and(isstring, isintent_nothide) }, { '_check': l_and(isstring, isintent_hide) }, { 'frompyobj': { debugcapi: '\tfprintf(stderr,"#vardebugshowvalue#\\n",slen(#varname#),#varname#);' },'_check': isstring,'_depend': '' }, { 'decl': ['\t#ctype# *#varname# = NULL;', '\tnpy_intp #varname#_Dims[#rank#] = {#rank*[-1]#};', '\tconst int #varname#_Rank = #rank#;', '\tPyArrayObject *capi_#varname#_tmp = NULL;', '\tint capi_#varname#_intent = 0;'],'callfortran': '#varname#,','return': { isintent_out: ',capi_#varname#_tmp' },'need': 'len..','_check': isarray }, { 'decl': '\tint capi_overwrite_#varname# = 1;','kwlistxa': '"overwrite_#varname#",','xaformat': 'i','keys_xa': ',&capi_overwrite_#varname#','docsignxa': 'overwrite_#varname#=1,','docsignxashort': 'overwrite_#varname#,','docstropt': 'overwrite_#varname# : input int, optional\\n    Default: 1','_check': l_and(isarray, isintent_overwrite) }, { 'frompyobj': '\tcapi_#varname#_intent |= (capi_overwrite_#varname#?0:F2PY_INTENT_COPY);','_check': l_and(isarray, isintent_overwrite),'_depend': '' }, { 'decl': '\tint capi_overwrite_#varname# = 0;','kwlistxa': '"overwrite_#varname#",','xaformat': 'i','keys_xa': ',&capi_overwrite_#varname#','docsignxa': 'overwrite_#varname#=0,','docsignxashort': 'overwrite_#varname#,','docstropt': 'overwrite_#varname# : input int, optional\\n    Default: 0','_check': l_and(isarray, isintent_copy) }, { 'frompyobj': '\tcapi_#varname#_intent |= (capi_overwrite_#varname#?0:F2PY_INTENT_COPY);','_check': l_and(isarray, isintent_copy),'_depend': '' }, { 'need': [{ hasinitvalue: 'forcomb' }, { hasinitvalue: 'CFUNCSMESS' }],'_check': isarray,'_depend': '' }, { 'decl': '\tPyObject *#varname#_capi = Py_None;','argformat': { isrequired: 'O' },'keyformat': { isoptional: 'O' },'args_capi': { isrequired: ',&#varname#_capi' },'keys_capi': { isoptional: ',&#varname#_capi' },'_check': l_and(isarray, isintent_nothide) }, { 'frompyobj': ['\t#setdims#;', '\tcapi_#varname#_intent |= #intent#;', { isintent_hide: '\tcapi_#varname#_tmp = array_from_pyobj(#atype#,#varname#_Dims,#varname#_Rank,capi_#varname#_intent,Py_None);' }, { isintent_nothide: '\tcapi_#varname#_tmp = array_from_pyobj(#atype#,#varname#_Dims,#varname#_Rank,capi_#varname#_intent,#varname#_capi);' }, """\
\tif (capi_#varname#_tmp == NULL) {
\t\tPyObject *exc, *val, *tb;
\t\tPyErr_Fetch(&exc, &val, &tb);
\t\tPyErr_SetString(exc ? exc : #modulename#_error,\"failed in converting #nth# `#varname#\' of #pyname# to C/Fortran array\" );
\t\tnpy_PyErr_ChainExceptionsCause(exc, val, tb);
\t} else {
\t\t#varname# = (#ctype# *)(PyArray_DATA(capi_#varname#_tmp));
""", { hasinitvalue: [{ isintent_nothide: '\tif (#varname#_capi == Py_None) {' }, { isintent_hide: '\t{' }, { iscomplexarray: '\t\t#ctype# capi_c;' }, """\
\t\tint *_i,capi_i=0;
\t\tCFUNCSMESS(\"#name#: Initializing #varname#=#init#\\n\");
\t\tif (initforcomb(PyArray_DIMS(capi_#varname#_tmp),PyArray_NDIM(capi_#varname#_tmp),1)) {
\t\t\twhile ((_i = nextforcomb()))
\t\t\t\t#varname#[capi_i++] = #init#; /* fortran way */
\t\t} else {
\t\t\tPyObject *exc, *val, *tb;
\t\t\tPyErr_Fetch(&exc, &val, &tb);
\t\t\tPyErr_SetString(exc ? exc : #modulename#_error,\"Initialization of #nth# #varname# failed (initforcomb).\");
\t\t\tnpy_PyErr_ChainExceptionsCause(exc, val, tb);
\t\t\tf2py_success = 0;
\t\t}
\t}
\tif (f2py_success) {"""] }],'cleanupfrompyobj': ['\t}  /*if (capi_#varname#_tmp == NULL) ... else of #varname#*/', { l_not(l_or(isintent_out, isintent_hide)): """\
\tif((PyObject *)capi_#varname#_tmp!=#varname#_capi) {
\t\tPy_XDECREF(capi_#varname#_tmp); }""" }, { l_and(isintent_hide, l_not(isintent_out)): """\t\tPy_XDECREF(capi_#varname#_tmp);""" }, { hasinitvalue: '\t}  /*if (f2py_success) of #varname# init*/' }],'_check': isarray,'_depend': '' }, { '_check': l_and(isarray, l_not(iscomplexarray)) }, { '_check': l_and(isarray, l_not(iscomplexarray), isintent_nothide) }, { 'need': '#ctype#','_check': isint1array,'_depend': '' }, { 'need': '#ctype#','_check': isunsigned_chararray,'_depend': '' }, { 'need': '#ctype#','_check': isunsigned_shortarray,'_depend': '' }, { 'need': '#ctype#','_check': isunsigned_long_longarray,'_depend': '' }, { 'need': '#ctype#','_check': iscomplexarray,'_depend': '' }, { 'callfortranappend': { isarrayofstrings: 'flen(#varname#),' },'need': 'string','_check': isstringarray }]
check_rules = [{ 'frompyobj': { debugcapi: '\tfprintf(stderr,\"debug-capi:Checking `#check#\'\\n\");' },'need': 'len..' }, { 'frompyobj': '\tCHECKSCALAR(#check#,\"#check#\",\"#nth# #varname#\",\"#varshowvalue#\",#varname#) {','cleanupfrompyobj': '\t} /*CHECKSCALAR(#check#)*/','need': 'CHECKSCALAR','_check': l_and(isscalar, l_not(iscomplex)),'_break': '' }, { 'frompyobj': '\tCHECKSTRING(#check#,\"#check#\",\"#nth# #varname#\",\"#varshowvalue#\",#varname#) {','cleanupfrompyobj': '\t} /*CHECKSTRING(#check#)*/','need': 'CHECKSTRING','_check': isstring,'_break': '' }, { 'need': 'CHECKARRAY','frompyobj': '\tCHECKARRAY(#check#,\"#check#\",\"#nth# #varname#\") {','cleanupfrompyobj': '\t} /*CHECKARRAY(#check#)*/','_check': isarray,'_break': '' }, { 'need': 'CHECKGENERIC','frompyobj': '\tCHECKGENERIC(#check#,\"#check#\",\"#nth# #varname#\") {','cleanupfrompyobj': '\t} /*CHECKGENERIC(#check#)*/' }]
def buildmodule(m, um):
    """
    Return
    """
    ...

stnd = { 1: 'st',2: 'nd',3: 'rd',4: 'th',5: 'th',6: 'th',7: 'th',8: 'th',9: 'th',0: 'th' }
def buildapi(rout):
    ...

